<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tafesech Chatbot</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #121212;
            --container-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --user-bubble-bg: #0d47a1;
            --tafesech-bubble-bg: #333333;
            --accent-color: #64ffda;
            --input-bg: #2a2a2a;
            --border-color: #444;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            font-family: 'Poppins', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-width: 800px;
            margin: 0 auto;
            border-radius: 12px;
            overflow: hidden;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem 2rem;
            background-color: var(--container-bg);
            border-bottom: 1px solid var(--border-color);
        }

        .header-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-color);
        }

        .header-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }
        
        select {
            background-color: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.4rem 0.6rem;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .messages {
            flex-grow: 1;
            padding: 2rem;
            overflow-y: auto;
            background-color: var(--bg-color);
            scroll-behavior: smooth;
        }

        .message-bubble {
            max-width: 70%;
            padding: 1rem 1.2rem;
            border-radius: 18px;
            margin-bottom: 1.5rem;
            line-height: 1.4;
            animation: fadeIn 0.3s ease-in-out;
        }

        .message-bubble.user {
            background-color: var(--user-bubble-bg);
            align-self: flex-end;
            margin-left: auto;
            border-bottom-right-radius: 4px;
        }

        .message-bubble.tafesech {
            background-color: var(--tafesech-bubble-bg);
            align-self: flex-start;
            margin-right: auto;
            border-bottom-left-radius: 4px;
        }
        
        .tafesech-bubble-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .input-area {
            display: flex;
            flex-direction: column;
            padding: 1rem 2rem;
            background-color: var(--container-bg);
            border-top: 1px solid var(--border-color);
        }

        .input-buttons {
            display: flex;
            justify-content: space-between;
            gap: 1rem;
            margin-bottom: 0.5rem;
        }

        .input-buttons button {
            flex: 1;
            background-color: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }

        .input-buttons button:hover {
            background-color: #383838;
            transform: translateY(-2px);
        }

        .input-buttons button.accent {
            background-color: var(--accent-color);
            color: var(--bg-color);
            border-color: var(--accent-color);
        }

        .input-buttons button.accent:hover {
            background-color: #4dd0e1;
        }

        .input-row {
            display: flex;
            align-items: flex-end;
            width: 100%;
        }

        .input-row textarea {
            flex-grow: 1;
            padding: 1rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--input-bg);
            color: var(--text-color);
            font-family: inherit;
            resize: none;
            outline: none;
            transition: border-color 0.2s;
            max-height: 100px;
        }
        
        .input-row textarea:focus {
            border-color: var(--accent-color);
        }
        
        .input-row button {
            background-color: var(--accent-color);
            color: var(--bg-color);
            border: none;
            padding: 0.5rem 1.5rem;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            margin-left: 1rem;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            height: fit-content;
        }

        .input-row button:hover {
            background-color: #4dd0e1;
            transform: translateY(-2px);
        }
        
        .loading-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            background-color: var(--accent-color);
            border-radius: 50%;
            margin: 0 2px;
            animation: dot-blink 1.4s infinite ease-in-out both;
        }
        
        .loading-dot:nth-child(1) { animation-delay: -0.32s; }
        .loading-dot:nth-child(2) { animation-delay: -0.16s; }
        .loading-dot:nth-child(3) { animation-delay: 0s; }

        @keyframes dot-blink {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        /* New styles for image preview */
        #image-preview {
            display: none;
            max-width: 100%;
            max-height: 150px;
            margin-top: 10px;
            border-radius: 8px;
        }
        
        /* New style for user message with image */
        .message-bubble.user img {
            max-width: 100%;
            border-radius: 8px;
            margin-top: 10px;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 1rem;
            }
            .header-controls {
                flex-wrap: wrap;
                justify-content: center;
                gap: 0.5rem;
            }
            .chat-container {
                border-radius: 0;
            }
            .messages {
                padding: 1rem;
            }
            .message-bubble {
                max-width: 90%;
            }
            .input-area {
                padding: 1rem;
            }
            .input-buttons, .input-row {
                flex-direction: column;
                gap: 0.5rem;
            }
            .input-row button {
                margin-left: 0;
            }
        }
    </style>
</head>
<body>

    <div class="chat-container">
        <div class="header">
            <div class="header-title">TAFESECH CHATBOT</div>
            <div class="header-controls">
                <div class="control-group">
                    <label for="language">Language:</label>
                    <select id="language">
                        <option value="en">English</option>
                        <option value="am">አማርኛ</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="synthesis">Speech Synthesis:</label>
                    <select id="synthesis">
                        <option value="disable">Disable</option>
                        <option value="gemini">Enable (Gemini API)</option>
                        <option value="browser">Browser TTS</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="messages" id="messages-container">
            <div class="message-bubble tafesech">Hello, I am Tafesech. How can I help you today?</div>
        </div>

        <div class="input-area">
            <div class="input-buttons">
                <button id="rephrase-button">✨ Rephrase</button>
                <button id="summarize-button">✨ Summarize</button>
            </div>
            <div class="input-row">
                <label for="image-upload" style="cursor:pointer; margin-right: 1rem;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <circle cx="8.5" cy="8.5" r="1.5"></circle>
                        <polyline points="21 15 16 10 5 21"></polyline>
                    </svg>
                </label>
                <input type="file" id="image-upload" accept="image/*" style="display: none;">

                <textarea id="message-input" placeholder="Write your message..."></textarea>
                <button id="send-button">Send</button>
            </div>
            <img id="image-preview" src="#" alt="Image Preview">
        </div>
    </div>
    <audio id="audio-player"></audio>

    <script>
        // --- UI Element References ---
        const messagesContainer = document.getElementById('messages-container');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const rephraseButton = document.getElementById('rephrase-button');
        const summarizeButton = document.getElementById('summarize-button');
        const languageSelect = document.getElementById('language');
        const synthesisSelect = document.getElementById('synthesis');
        const audioPlayer = document.getElementById('audio-player');
        
        // New references for image elements
        const imageUpload = document.getElementById('image-upload');
        const imagePreview = document.getElementById('image-preview');

        // --- State Variables ---
        let chatHistory = [];
        const apiKey = "AIzaSyBsbvLMhfjuzfvRHb4bRJfTmfzdCsd6EZI"; // PASTE YOUR API KEY HERE

        // --- Helper Functions ---
        
        /**
         * Converts a Base64 string to an ArrayBuffer.
         * @param {string} base64 - The Base64 string to convert.
         * @returns {ArrayBuffer} The ArrayBuffer representation.
         */
        const base64ToArrayBuffer = (base64) => {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        };

        /**
         * Converts PCM data to a WAV Blob.
         * @param {Int16Array} pcmData - The raw PCM audio data.
         * @param {number} sampleRate - The sample rate of the audio.
         * @returns {Blob} The WAV audio Blob.
         */
        const pcmToWav = (pcmData, sampleRate) => {
            const buffer = new ArrayBuffer(44 + pcmData.byteLength);
            const view = new DataView(buffer);
            const writeString = (view, offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };

            // RIFF chunk descriptor
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + pcmData.byteLength, true);
            writeString(view, 8, 'WAVE');

            // fmt chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); // PCM format
            view.setUint16(22, 1, true); // Mono channel
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true); // byte rate
            view.setUint16(32, 2, true); // block align
            view.setUint16(34, 16, true); // bits per sample

            // data chunk
            writeString(view, 36, 'data');
            view.setUint32(40, pcmData.byteLength, true);

            // Write the PCM data
            const pcmBuffer = new Uint8Array(pcmData.buffer);
            for (let i = 0; i < pcmData.byteLength; i++) {
                view.setUint8(44 + i, pcmBuffer[i]);
            }

            return new Blob([view], { type: 'audio/wav' });
        };
        
        /**
         * Displays a message in the chat window.
         * @param {string} sender - 'user' or 'tafesech'.
         * @param {string} message - The message content.
         */
        const displayMessage = (sender, message) => {
            const bubble = document.createElement('div');
            bubble.className = `message-bubble ${sender}`;
            bubble.textContent = message;
            messagesContainer.appendChild(bubble);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        };
        
        /**
         * Handles the sending of a message to the bot, including images.
         */
        const sendMessage = async () => {
            const msg = messageInput.value.trim();
            const imageFile = imageUpload.files[0];
            
            // Don't send if there's no text or image
            if (!msg && !imageFile) return;

            // Display user message and clear inputs
            let userMessageContent = msg;
            if (imageFile) {
                const reader = new FileReader();
                reader.readAsDataURL(imageFile);
                reader.onload = function(e) {
                    const bubble = document.createElement('div');
                    bubble.className = `message-bubble user`;
                    
                    if (msg) {
                        const textPart = document.createElement('p');
                        textPart.textContent = msg;
                        bubble.appendChild(textPart);
                    }
                    
                    const img = document.createElement('img');
                    img.src = e.target.result;
                    img.style.maxWidth = '100%';
                    img.style.borderRadius = '8px';
                    img.style.marginTop = msg ? '10px' : '0';
                    bubble.appendChild(img);
                    
                    messagesContainer.appendChild(bubble);
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                };
            } else {
                displayMessage('user', msg);
            }

            messageInput.value = '';
            messageInput.style.height = 'auto';
            imageUpload.value = '';
            imagePreview.style.display = 'none';

            // Add loading dots
            const loadingBubble = document.createElement('div');
            loadingBubble.className = 'message-bubble tafesech';
            loadingBubble.innerHTML = '<span class="loading-dot"></span><span class="loading-dot"></span><span class="loading-dot"></span>';
            messagesContainer.appendChild(loadingBubble);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Create the content payload for the API request
            let contents = [];
            
            // If there's a file, convert it to Base64 and add it to the parts
            if (imageFile) {
                const base64Data = await new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result.split(',')[1]);
                    reader.readAsDataURL(imageFile);
                });

                contents.push({
                    role: "user",
                    parts: [
                        {
                            text: msg
                        },
                        {
                            inlineData: {
                                mimeType: imageFile.type,
                                data: base64Data
                            }
                        }
                    ]
                });
            } else {
                contents.push({ role: "user", parts: [{ text: msg }] });
            }

            // Keywords to check for developer-related questions
            const developerKeywords = ['who created', 'who made', 'who developed', 'who develops', 'who creates', 'who makes', 'created by', 'made by', 'developer'];
            const lowerCaseMsg = msg.toLowerCase();
            const isDeveloperQuestion = developerKeywords.some(keyword => lowerCaseMsg.includes(keyword));

            if (isDeveloperQuestion) {
                loadingBubble.remove();
                const creatorResponse = "I was created by a developer named a13x.";
                displayMessage('tafesech', creatorResponse);
                if (synthesisSelect.value !== 'disable') {
                    await textToSpeech(creatorResponse);
                }
                return;
            }

            const language = languageSelect.value;
            let prompt = `Act as an AI assistant named Tafesech. Respond to the following query. Keep the response concise and helpful. Respond in ${language === 'am' ? 'Amharic' : 'English'}.`;
            
            try {
                const payload = {
                    contents: contents,
                };
                
                // Use the multimodal model for text and images
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;

                let response = null;
                let retries = 0;
                const maxRetries = 5;
                const baseDelay = 1000;

                while (!response && retries < maxRetries) {
                    try {
                        response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        if (response.status === 429) {
                            response = null;
                            retries++;
                            const delay = baseDelay * Math.pow(2, retries);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                    } catch (e) {
                        retries++;
                        const delay = baseDelay * Math.pow(2, retries);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
                
                if (!response) {
                    throw new Error("Failed to get response from Gemini API after multiple retries.");
                }

                const result = await response.json();
                const text = result?.candidates?.[0]?.content?.parts?.[0]?.text;

                loadingBubble.remove();
                if (text) {
                    displayMessage('tafesech', text);
                    chatHistory.push({ role: "model", parts: [{ text: text }] });
                    
                    if (synthesisSelect.value !== 'disable') {
                        await textToSpeech(text);
                    }
                } else {
                    displayMessage('tafesech', 'Sorry, I couldn\'t generate a response.');
                }

            } catch (error) {
                console.error("Error fetching Gemini response:", error);
                loadingBubble.remove();
                displayMessage('tafesech', 'An error occurred. Please try again.');
            }
        };

        /**
         * Rephrases the text in the input box using the Gemini API.
         */
        const rephraseText = async () => {
            const msg = messageInput.value.trim();
            if (!msg) {
                displayMessage('tafesech', 'Please enter some text to rephrase.');
                return;
            }

            const prompt = `Rephrase the following text to be more concise and clear. Do not add any new information. Just rephrase the provided text. Text: "${msg}"`;
            
            const originalText = messageInput.value;
            messageInput.value = 'Rephrasing...';
            sendButton.disabled = true;

            try {
                const payload = {
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                };

                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                
                let response = null;
                let retries = 0;
                const maxRetries = 5;
                const baseDelay = 1000;

                while (!response && retries < maxRetries) {
                    try {
                        response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        if (response.status === 429) {
                            response = null;
                            retries++;
                            const delay = baseDelay * Math.pow(2, retries);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                    } catch (e) {
                        retries++;
                        const delay = baseDelay * Math.pow(2, retries);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }

                if (!response) {
                    throw new Error("Failed to get response from Gemini API after multiple retries.");
                }

                const result = await response.json();
                const rephrasedText = result?.candidates?.[0]?.content?.parts?.[0]?.text;

                if (rephrasedText) {
                    messageInput.value = rephrasedText;
                } else {
                    messageInput.value = originalText;
                    displayMessage('tafesech', 'Sorry, I couldn\'t rephrase that.');
                }
            } catch (error) {
                console.error("Error rephrasing text:", error);
                messageInput.value = originalText;
                displayMessage('tafesech', 'An error occurred. Please try again.');
            } finally {
                sendButton.disabled = false;
                messageInput.style.height = 'auto';
                messageInput.style.height = messageInput.scrollHeight + 'px';
            }
        };

        /**
         * Summarizes the chat history using the Gemini API.
         */
        const summarizeChat = async () => {
            if (chatHistory.length === 0) {
                displayMessage('tafesech', 'There is no chat history to summarize.');
                return;
            }
            
            const loadingBubble = document.createElement('div');
            loadingBubble.className = 'message-bubble tafesech';
            loadingBubble.innerHTML = 'Summarizing... <span class="loading-dot"></span><span class="loading-dot"></span><span class="loading-dot"></span>';
            messagesContainer.appendChild(loadingBubble);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            const prompt = "Please provide a concise summary of the following conversation.";
            const summaryPayload = {
                contents: [
                    ...chatHistory,
                    { role: "user", parts: [{ text: prompt }] }
                ],
            };

            try {
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                
                let response = null;
                let retries = 0;
                const maxRetries = 5;
                const baseDelay = 1000;

                while (!response && retries < maxRetries) {
                    try {
                        response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(summaryPayload)
                        });
                        if (response.status === 429) {
                            response = null;
                            retries++;
                            const delay = baseDelay * Math.pow(2, retries);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                    } catch (e) {
                        retries++;
                        const delay = baseDelay * Math.pow(2, retries);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
                
                if (!response) {
                    throw new Error("Failed to get response from Gemini API after multiple retries.");
                }

                const result = await response.json();
                const summaryText = result?.candidates?.[0]?.content?.parts?.[0]?.text;

                loadingBubble.remove();
                if (summaryText) {
                    displayMessage('tafesech', `**Summary:**\n${summaryText}`);
                } else {
                    displayMessage('tafesech', 'Sorry, I couldn\'t create a summary.');
                }
            } catch (error) {
                console.error("Error summarizing chat:", error);
                loadingBubble.remove();
                displayMessage('tafesech', 'An error occurred while summarizing. Please try again.');
            }
        };


        /**
         * Converts text to speech and plays the audio.
         * @param {string} text - The text to synthesize.
         */
        const textToSpeech = async (text) => {
            const selectedOption = synthesisSelect.value;
            
            if (selectedOption === 'browser') {
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(text);
                    const langCode = languageSelect.value === 'am' ? 'am-ET' : 'en-US';
                    utterance.lang = langCode;
                    window.speechSynthesis.speak(utterance);
                } else {
                    console.error("Browser does not support the Web Speech API.");
                    displayMessage('tafesech', 'Your browser does not support text-to-speech.');
                }
                return;
            }

            try {
                const payload = {
                    contents: [{
                        parts: [{ text: text }]
                    }],
                    generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: {
                            voiceConfig: {
                                prebuiltVoiceConfig: { voiceName: languageSelect.value === 'am' ? 'Algenib' : 'Zephyr' }
                            }
                        }
                    },
                    model: "gemini-2.5-flash-preview-tts"
                };

                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

                let response = null;
                let retries = 0;
                const maxRetries = 5;
                const baseDelay = 1000;

                while (!response && retries < maxRetries) {
                    try {
                        response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        if (response.status === 429) {
                            response = null;
                            retries++;
                            const delay = baseDelay * Math.pow(2, retries);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                    } catch (e) {
                        retries++;
                        const delay = baseDelay * Math.pow(2, retries);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }

                if (!response) {
                    throw new Error("Failed to get response from TTS API after multiple retries.");
                }

                const result = await response.json();
                
                if (!result || !result.candidates || result.candidates.length === 0 || !result.candidates[0].content || !result.candidates[0].content.parts) {
                    console.error("Invalid response structure from TTS API:", result);
                    displayMessage('tafesech', 'Sorry, I couldn\'t generate audio. The API response was invalid.');
                    return;
                }

                const audioPart = result.candidates[0].content.parts.find(p => p.inlineData && p.inlineData.mimeType.startsWith("audio/"));
                
                if (!audioPart) {
                    console.error("Audio part not found in TTS API response:", result);
                    displayMessage('tafesech', 'Sorry, I couldn\'t generate audio. No audio data was found in the API response.');
                    return;
                }

                const audioData = audioPart.inlineData.data;
                const mimeType = audioPart.inlineData.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/")) {
                    const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                    if (!sampleRateMatch || !sampleRateMatch[1]) {
                        console.error("Sample rate not found in audio mime type:", mimeType);
                        return;
                    }
                    const sampleRate = parseInt(sampleRateMatch[1], 10);
                    const pcmData = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    audioPlayer.src = audioUrl;
                    audioPlayer.play();
                } else {
                    console.error("Invalid audio data or mime type:", mimeType);
                    displayMessage('tafesech', 'Sorry, I couldn\'t generate audio. The data was not in a valid format.');
                }
            } catch (error) {
                console.error("Error with TTS:", error);
                displayMessage('tafesech', 'An error occurred while generating audio. Please try a different synthesis option.');
            }
        };
        
        // --- Event Listeners ---
        messageInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        });

        sendButton.addEventListener('click', sendMessage);
        rephraseButton.addEventListener('click', rephraseText);
        summarizeButton.addEventListener('click', summarizeChat);
        
        // Handle image upload and preview
        imageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    imagePreview.src = e.target.result;
                    imagePreview.style.display = 'block';
                };
                reader.readAsDataURL(file);
            } else {
                imagePreview.style.display = 'none';
            }
        });

        // Auto-resize the input textarea
        messageInput.addEventListener('input', () => {
            messageInput.style.height = 'auto';
            messageInput.style.height = messageInput.scrollHeight + 'px';
        });

        // Set the default synthesis option when language changes
        languageSelect.addEventListener('change', () => {
            if (languageSelect.value === 'am') {
                synthesisSelect.value = 'browser';
            } else {
                synthesisSelect.value = 'gemini';
            }
        });

        // Initial setup on page load
        document.addEventListener('DOMContentLoaded', () => {
            if (languageSelect.value === 'am') {
                synthesisSelect.value = 'browser';
            }
        });
        
    </script>

</body>
</html>